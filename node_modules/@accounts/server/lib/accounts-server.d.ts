import Emittery from 'emittery';
import { User, LoginResult, Tokens, Session, ImpersonationResult, HookListener, AuthenticationService, ConnectionInformations } from '@accounts/types';
import { AccountsServerOptions } from './types/accounts-server-options';
import { EmailTemplateType } from './types/email-template-type';
declare const defaultOptions: {
    ambiguousErrorMessages: boolean;
    tokenSecret: string;
    tokenConfigs: {
        accessToken: {
            expiresIn: string;
        };
        refreshToken: {
            expiresIn: string;
        };
    };
    emailTemplates: import("./types/email-templates-type").EmailTemplatesType;
    userObjectSanitizer: (user: User) => User;
    sendMail: (mail: object) => Promise<void>;
    siteUrl: string;
    createNewSessionTokenOnRefresh: boolean;
};
export declare class AccountsServer {
    options: AccountsServerOptions & typeof defaultOptions;
    private services;
    private db;
    private hooks;
    constructor(options: AccountsServerOptions, services: {
        [key: string]: AuthenticationService;
    });
    getServices(): {
        [key: string]: AuthenticationService;
    };
    getOptions(): AccountsServerOptions;
    getHooks(): Emittery;
    /**
     * Subscribe to an accounts-js event.
     * ```javascript
     * accountsServer.on(ServerHooks.ValidateLogin, ({ user }) => {
     *   // This hook is called every time a user try to login
     *   // You can use it to only allow users with verified email to login
     * });
     * ```
     */
    on(eventName: string, callback: HookListener): () => void;
    authenticateWithService(serviceName: string, params: any, infos: ConnectionInformations): Promise<boolean>;
    loginWithService(serviceName: string, params: any, infos: ConnectionInformations): Promise<LoginResult>;
    /**
     * @description Server use only.
     * This method creates a session without authenticating any user identity.
     * Any authentication should happen before calling this function.
     * @param {User} userId - The user object.
     * @param {string} ip - User's ip.
     * @param {string} userAgent - User's client agent.
     * @returns {Promise<LoginResult>} - Session tokens and user object.
     */
    loginWithUser(user: User, infos: ConnectionInformations): Promise<LoginResult>;
    /**
     * @description Impersonate to another user.
     * @param {string} accessToken - User access token.
     * @param {object} impersonated - impersonated user.
     * @param {string} ip - The user ip.
     * @param {string} userAgent - User user agent.
     * @returns {Promise<Object>} - ImpersonationResult
     */
    impersonate(accessToken: string, impersonated: {
        userId?: string;
        username?: string;
        email?: string;
    }, ip: string, userAgent: string): Promise<ImpersonationResult>;
    /**
     * @description Refresh a user token.
     * @param {string} accessToken - User access token.
     * @param {string} refreshToken - User refresh token.
     * @param {string} ip - User ip.
     * @param {string} userAgent - User user agent.
     * @returns {Promise<Object>} - LoginResult.
     */
    refreshTokens(accessToken: string, refreshToken: string, ip: string, userAgent: string): Promise<LoginResult>;
    /**
     * @description Refresh a user token.
     * @param {string} token - User session token.
     * @param {boolean} isImpersonated - Should be true if impersonating another user.
     * @returns {Promise<Object>} - Return a new accessToken and refreshToken.
     */
    createTokens({ token, isImpersonated, userId, }: {
        token: string;
        isImpersonated?: boolean;
        userId: string;
    }): Tokens;
    /**
     * @description Logout a user and invalidate his session.
     * @param {string} accessToken - User access token.
     * @returns {Promise<void>} - Return a promise.
     */
    logout(accessToken: string): Promise<void>;
    resumeSession(accessToken: string): Promise<User>;
    /**
     * @description Find a session by his token.
     * @param {string} accessToken
     * @returns {Promise<Session>} - Return a session.
     */
    findSessionByAccessToken(accessToken: string): Promise<Session>;
    /**
     * @description Find a user by his id.
     * @param {string} userId - User id.
     * @returns {Promise<Object>} - Return a user or null if not found.
     */
    findUserById(userId: string): Promise<User | null>;
    /**
     * @description Deactivate a user, the user will not be able to login until his account is reactivated.
     * @param {string} userId - User id.
     * @returns {Promise<void>} - Return a Promise.
     */
    deactivateUser(userId: string): Promise<void>;
    /**
     * @description Activate a user.
     * @param {string} userId - User id.
     * @returns {Promise<void>} - Return a Promise.
     */
    activateUser(userId: string): Promise<void>;
    prepareMail(to: string, token: string, user: User, pathFragment: string, emailTemplate: EmailTemplateType, from: string): any;
    sanitizeUser(user: User): User;
    private internalUserSanitizer;
    private defaultPrepareEmail;
    private defaultCreateTokenizedUrl;
    private createSessionToken;
}
export default AccountsServer;
