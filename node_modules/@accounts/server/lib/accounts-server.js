"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lodash_1 = require("lodash");
var jwt = tslib_1.__importStar(require("jsonwebtoken"));
var emittery_1 = tslib_1.__importDefault(require("emittery"));
var tokens_1 = require("./utils/tokens");
var email_1 = require("./utils/email");
var server_hooks_1 = require("./utils/server-hooks");
var defaultOptions = {
    ambiguousErrorMessages: true,
    tokenSecret: 'secret',
    tokenConfigs: {
        accessToken: {
            expiresIn: '90m',
        },
        refreshToken: {
            expiresIn: '7d',
        },
    },
    emailTemplates: email_1.emailTemplates,
    userObjectSanitizer: function (user) { return user; },
    sendMail: email_1.sendMail,
    siteUrl: 'http://localhost:3000',
    createNewSessionTokenOnRefresh: false,
};
var AccountsServer = /** @class */ (function () {
    function AccountsServer(options, services) {
        this.options = lodash_1.merge(tslib_1.__assign({}, defaultOptions), options);
        if (!this.options.db) {
            throw new Error('A database driver is required');
        }
        if (this.options.tokenSecret === defaultOptions.tokenSecret) {
            console.log("\nYou are using the default secret \"" + this.options.tokenSecret + "\" which is not secure.\nPlease change it with a strong random token.");
        }
        this.services = services || {};
        this.db = this.options.db;
        // Set the db to all services
        for (var service in this.services) {
            this.services[service].setStore(this.db);
            this.services[service].server = this;
        }
        // Initialize hooks
        this.hooks = new emittery_1.default();
    }
    AccountsServer.prototype.getServices = function () {
        return this.services;
    };
    AccountsServer.prototype.getOptions = function () {
        return this.options;
    };
    AccountsServer.prototype.getHooks = function () {
        return this.hooks;
    };
    /**
     * Subscribe to an accounts-js event.
     * ```javascript
     * accountsServer.on(ServerHooks.ValidateLogin, ({ user }) => {
     *   // This hook is called every time a user try to login
     *   // You can use it to only allow users with verified email to login
     * });
     * ```
     */
    AccountsServer.prototype.on = function (eventName, callback) {
        var _this = this;
        this.hooks.on(eventName, callback);
        return function () { return _this.hooks.off(eventName, callback); };
    };
    AccountsServer.prototype.authenticateWithService = function (serviceName, params, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hooksInfo, user, err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hooksInfo = {
                            // The service name, such as “password” or “twitter”.
                            service: serviceName,
                            // The connection informations <ConnectionInformations>
                            connection: infos,
                            // Params received
                            params: params,
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        if (!this.services[serviceName]) {
                            throw new Error("No service with the name " + serviceName + " was registered.");
                        }
                        return [4 /*yield*/, this.services[serviceName].authenticate(params)];
                    case 2:
                        user = _a.sent();
                        hooksInfo.user = user;
                        if (!user) {
                            throw new Error("Service " + serviceName + " was not able to authenticate user");
                        }
                        if (user.deactivated) {
                            throw new Error('Your account has been deactivated');
                        }
                        this.hooks.emit(server_hooks_1.ServerHooks.AuthenticateSuccess, hooksInfo);
                        return [2 /*return*/, true];
                    case 3:
                        err_1 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.AuthenticateError, tslib_1.__assign(tslib_1.__assign({}, hooksInfo), { error: err_1 }));
                        throw err_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    AccountsServer.prototype.loginWithService = function (serviceName, params, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hooksInfo, user, loginResult, err_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hooksInfo = {
                            // The service name, such as “password” or “twitter”.
                            service: serviceName,
                            // The connection informations <ConnectionInformations>
                            connection: infos,
                            // Params received
                            params: params,
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        if (!this.services[serviceName]) {
                            throw new Error("No service with the name " + serviceName + " was registered.");
                        }
                        return [4 /*yield*/, this.services[serviceName].authenticate(params)];
                    case 2:
                        user = _a.sent();
                        hooksInfo.user = user;
                        if (!user) {
                            throw new Error("Service " + serviceName + " was not able to authenticate user");
                        }
                        if (user.deactivated) {
                            throw new Error('Your account has been deactivated');
                        }
                        // Let the user validate the login attempt
                        return [4 /*yield*/, this.hooks.emitSerial(server_hooks_1.ServerHooks.ValidateLogin, hooksInfo)];
                    case 3:
                        // Let the user validate the login attempt
                        _a.sent();
                        return [4 /*yield*/, this.loginWithUser(user, infos)];
                    case 4:
                        loginResult = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LoginSuccess, hooksInfo);
                        return [2 /*return*/, loginResult];
                    case 5:
                        err_2 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LoginError, tslib_1.__assign(tslib_1.__assign({}, hooksInfo), { error: err_2 }));
                        throw err_2;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Server use only.
     * This method creates a session without authenticating any user identity.
     * Any authentication should happen before calling this function.
     * @param {User} userId - The user object.
     * @param {string} ip - User's ip.
     * @param {string} userAgent - User's client agent.
     * @returns {Promise<LoginResult>} - Session tokens and user object.
     */
    AccountsServer.prototype.loginWithUser = function (user, infos) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var ip, userAgent, token, sessionId, _a, accessToken, refreshToken;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        ip = infos.ip, userAgent = infos.userAgent;
                        return [4 /*yield*/, this.createSessionToken(user)];
                    case 1:
                        token = _b.sent();
                        return [4 /*yield*/, this.db.createSession(user.id, token, {
                                ip: ip,
                                userAgent: userAgent,
                            })];
                    case 2:
                        sessionId = _b.sent();
                        _a = this.createTokens({
                            token: token,
                            userId: user.id,
                        }), accessToken = _a.accessToken, refreshToken = _a.refreshToken;
                        return [2 /*return*/, {
                                sessionId: sessionId,
                                tokens: {
                                    refreshToken: refreshToken,
                                    accessToken: accessToken,
                                },
                            }];
                }
            });
        });
    };
    /**
     * @description Impersonate to another user.
     * @param {string} accessToken - User access token.
     * @param {object} impersonated - impersonated user.
     * @param {string} ip - The user ip.
     * @param {string} userAgent - User user agent.
     * @returns {Promise<Object>} - ImpersonationResult
     */
    AccountsServer.prototype.impersonate = function (accessToken, impersonated, ip, userAgent) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var session, user, impersonatedUser, isAuthorized, token, newSessionId, impersonationTokens, impersonationResult, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 11, , 12]);
                        if (!lodash_1.isString(accessToken)) {
                            throw new Error('An access token is required');
                        }
                        try {
                            jwt.verify(accessToken, this.options.tokenSecret);
                        }
                        catch (err) {
                            throw new Error('Access token is not valid');
                        }
                        return [4 /*yield*/, this.findSessionByAccessToken(accessToken)];
                    case 1:
                        session = _a.sent();
                        if (!session.valid) {
                            throw new Error('Session is not valid for user');
                        }
                        return [4 /*yield*/, this.db.findUserById(session.userId)];
                    case 2:
                        user = _a.sent();
                        if (!user) {
                            throw new Error('User not found');
                        }
                        impersonatedUser = void 0;
                        if (!impersonated.userId) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.db.findUserById(impersonated.userId)];
                    case 3:
                        impersonatedUser = _a.sent();
                        return [3 /*break*/, 8];
                    case 4:
                        if (!impersonated.username) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.db.findUserByUsername(impersonated.username)];
                    case 5:
                        impersonatedUser = _a.sent();
                        return [3 /*break*/, 8];
                    case 6:
                        if (!impersonated.email) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.db.findUserByEmail(impersonated.email)];
                    case 7:
                        impersonatedUser = _a.sent();
                        _a.label = 8;
                    case 8:
                        if (!impersonatedUser) {
                            if (this.options.ambiguousErrorMessages) {
                                return [2 /*return*/, { authorized: false }];
                            }
                            throw new Error("Impersonated user not found");
                        }
                        if (!this.options.impersonationAuthorize) {
                            return [2 /*return*/, { authorized: false }];
                        }
                        return [4 /*yield*/, this.options.impersonationAuthorize(user, impersonatedUser)];
                    case 9:
                        isAuthorized = _a.sent();
                        if (!isAuthorized) {
                            return [2 /*return*/, { authorized: false }];
                        }
                        token = tokens_1.generateRandomToken();
                        return [4 /*yield*/, this.db.createSession(impersonatedUser.id, token, {
                                ip: ip,
                                userAgent: userAgent,
                            }, { impersonatorUserId: user.id })];
                    case 10:
                        newSessionId = _a.sent();
                        impersonationTokens = this.createTokens({
                            token: newSessionId,
                            isImpersonated: true,
                            userId: user.id,
                        });
                        impersonationResult = {
                            authorized: true,
                            tokens: impersonationTokens,
                            user: this.sanitizeUser(impersonatedUser),
                        };
                        this.hooks.emit(server_hooks_1.ServerHooks.ImpersonationSuccess, {
                            user: user,
                            impersonationResult: impersonationResult,
                        });
                        return [2 /*return*/, impersonationResult];
                    case 11:
                        e_1 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.ImpersonationError, e_1);
                        throw e_1;
                    case 12: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Refresh a user token.
     * @param {string} accessToken - User access token.
     * @param {string} refreshToken - User refresh token.
     * @param {string} ip - User ip.
     * @param {string} userAgent - User user agent.
     * @returns {Promise<Object>} - LoginResult.
     */
    AccountsServer.prototype.refreshTokens = function (accessToken, refreshToken, ip, userAgent) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sessionToken, decodedAccessToken, session, user, newToken, tokens, result, err_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 8, , 9]);
                        if (!lodash_1.isString(accessToken) || !lodash_1.isString(refreshToken)) {
                            throw new Error('An accessToken and refreshToken are required');
                        }
                        sessionToken = void 0;
                        try {
                            jwt.verify(refreshToken, this.options.tokenSecret);
                            decodedAccessToken = jwt.verify(accessToken, this.options.tokenSecret, {
                                ignoreExpiration: true,
                            });
                            sessionToken = decodedAccessToken.data.token;
                        }
                        catch (err) {
                            throw new Error('Tokens are not valid');
                        }
                        return [4 /*yield*/, this.db.findSessionByToken(sessionToken)];
                    case 1:
                        session = _a.sent();
                        if (!session) {
                            throw new Error('Session not found');
                        }
                        if (!session.valid) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.db.findUserById(session.userId)];
                    case 2:
                        user = _a.sent();
                        if (!user) {
                            throw new Error('User not found');
                        }
                        newToken = void 0;
                        if (!this.options.createNewSessionTokenOnRefresh) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.createSessionToken(user)];
                    case 3:
                        newToken = _a.sent();
                        _a.label = 4;
                    case 4:
                        tokens = this.createTokens({ token: newToken || sessionToken, userId: user.id });
                        return [4 /*yield*/, this.db.updateSession(session.id, { ip: ip, userAgent: userAgent }, newToken)];
                    case 5:
                        _a.sent();
                        result = {
                            sessionId: session.id,
                            user: this.sanitizeUser(user),
                            tokens: tokens,
                        };
                        this.hooks.emit(server_hooks_1.ServerHooks.RefreshTokensSuccess, result);
                        return [2 /*return*/, result];
                    case 6: throw new Error('Session is no longer valid');
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        err_3 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.RefreshTokensError, err_3);
                        throw err_3;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Refresh a user token.
     * @param {string} token - User session token.
     * @param {boolean} isImpersonated - Should be true if impersonating another user.
     * @returns {Promise<Object>} - Return a new accessToken and refreshToken.
     */
    AccountsServer.prototype.createTokens = function (_a) {
        var token = _a.token, _b = _a.isImpersonated, isImpersonated = _b === void 0 ? false : _b, userId = _a.userId;
        var _c = this.options, tokenSecret = _c.tokenSecret, tokenConfigs = _c.tokenConfigs;
        var jwtData = {
            token: token,
            isImpersonated: isImpersonated,
            userId: userId,
        };
        var accessToken = tokens_1.generateAccessToken({
            data: jwtData,
            secret: tokenSecret,
            config: tokenConfigs.accessToken,
        });
        var refreshToken = tokens_1.generateRefreshToken({
            secret: tokenSecret,
            config: tokenConfigs.refreshToken,
        });
        return { accessToken: accessToken, refreshToken: refreshToken };
    };
    /**
     * @description Logout a user and invalidate his session.
     * @param {string} accessToken - User access token.
     * @returns {Promise<void>} - Return a promise.
     */
    AccountsServer.prototype.logout = function (accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var session, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 5, , 6]);
                        return [4 /*yield*/, this.findSessionByAccessToken(accessToken)];
                    case 1:
                        session = _a.sent();
                        if (!session.valid) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.db.invalidateSession(session.id)];
                    case 2:
                        _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LogoutSuccess, {
                            session: session,
                            accessToken: accessToken,
                        });
                        return [3 /*break*/, 4];
                    case 3: throw new Error('Session is no longer valid');
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        error_1 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.LogoutError, error_1);
                        throw error_1;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    AccountsServer.prototype.resumeSession = function (accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var session, user, e_2, e_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 8, , 9]);
                        return [4 /*yield*/, this.findSessionByAccessToken(accessToken)];
                    case 1:
                        session = _a.sent();
                        if (!session.valid) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.db.findUserById(session.userId)];
                    case 2:
                        user = _a.sent();
                        if (!user) {
                            throw new Error('User not found');
                        }
                        if (!this.options.resumeSessionValidator) return [3 /*break*/, 6];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.options.resumeSessionValidator(user, session)];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_2 = _a.sent();
                        throw new Error(e_2);
                    case 6:
                        this.hooks.emit(server_hooks_1.ServerHooks.ResumeSessionSuccess, { user: user, accessToken: accessToken });
                        return [2 /*return*/, this.sanitizeUser(user)];
                    case 7:
                        this.hooks.emit(server_hooks_1.ServerHooks.ResumeSessionError, new Error('Invalid Session'));
                        throw new Error('Invalid Session');
                    case 8:
                        e_3 = _a.sent();
                        this.hooks.emit(server_hooks_1.ServerHooks.ResumeSessionError, e_3);
                        throw e_3;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @description Find a session by his token.
     * @param {string} accessToken
     * @returns {Promise<Session>} - Return a session.
     */
    AccountsServer.prototype.findSessionByAccessToken = function (accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sessionToken, decodedAccessToken, session;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!lodash_1.isString(accessToken)) {
                            throw new Error('An accessToken is required');
                        }
                        try {
                            decodedAccessToken = jwt.verify(accessToken, this.options.tokenSecret);
                            sessionToken = decodedAccessToken.data.token;
                        }
                        catch (err) {
                            throw new Error('Tokens are not valid');
                        }
                        return [4 /*yield*/, this.db.findSessionByToken(sessionToken)];
                    case 1:
                        session = _a.sent();
                        if (!session) {
                            throw new Error('Session not found');
                        }
                        return [2 /*return*/, session];
                }
            });
        });
    };
    /**
     * @description Find a user by his id.
     * @param {string} userId - User id.
     * @returns {Promise<Object>} - Return a user or null if not found.
     */
    AccountsServer.prototype.findUserById = function (userId) {
        return this.db.findUserById(userId);
    };
    /**
     * @description Deactivate a user, the user will not be able to login until his account is reactivated.
     * @param {string} userId - User id.
     * @returns {Promise<void>} - Return a Promise.
     */
    AccountsServer.prototype.deactivateUser = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.db.setUserDeactivated(userId, true)];
            });
        });
    };
    /**
     * @description Activate a user.
     * @param {string} userId - User id.
     * @returns {Promise<void>} - Return a Promise.
     */
    AccountsServer.prototype.activateUser = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.db.setUserDeactivated(userId, false)];
            });
        });
    };
    AccountsServer.prototype.prepareMail = function (to, token, user, pathFragment, emailTemplate, from) {
        if (this.options.prepareMail) {
            return this.options.prepareMail(to, token, user, pathFragment, emailTemplate, from);
        }
        return this.defaultPrepareEmail(to, token, user, pathFragment, emailTemplate, from);
    };
    AccountsServer.prototype.sanitizeUser = function (user) {
        var userObjectSanitizer = this.options.userObjectSanitizer;
        return userObjectSanitizer(this.internalUserSanitizer(user), lodash_1.omit, lodash_1.pick);
    };
    AccountsServer.prototype.internalUserSanitizer = function (user) {
        return lodash_1.omit(user, ['services']);
    };
    AccountsServer.prototype.defaultPrepareEmail = function (to, token, user, pathFragment, emailTemplate, from) {
        var tokenizedUrl = this.defaultCreateTokenizedUrl(pathFragment, token);
        return {
            from: emailTemplate.from || from,
            to: to,
            subject: emailTemplate.subject(user),
            text: emailTemplate.text(user, tokenizedUrl),
            html: emailTemplate.html && emailTemplate.html(user, tokenizedUrl),
        };
    };
    AccountsServer.prototype.defaultCreateTokenizedUrl = function (pathFragment, token) {
        var siteUrl = this.options.siteUrl;
        return siteUrl + "/" + pathFragment + "/" + token;
    };
    AccountsServer.prototype.createSessionToken = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.options.tokenCreator
                        ? this.options.tokenCreator.createToken(user)
                        : tokens_1.generateRandomToken()];
            });
        });
    };
    return AccountsServer;
}());
exports.AccountsServer = AccountsServer;
exports.default = AccountsServer;
//# sourceMappingURL=accounts-server.js.map